import type { Request, Response } from 'express';
import mongoose from 'mongoose';
import SpacedRepetition from '@/models/Anki.ts';
import ContentBlock, { ContentBlockType } from '@/models/ContentBlock.ts';
import Topic from '@/models/Topic.ts';
import { createEmptyCard, FSRS, Rating, State } from 'ts-fsrs';
import type { Card } from 'ts-fsrs';
import { getFSRSParams } from '@/config/fsrs-config.ts';

export class AnkiController {

    static async getSession(req: Request, res: Response) {
        try {
            const user = req.user;
            if (!user) throw new Error('User not found');
            const userId = user._id;
            const { spaceId, subjectId, topicId, limit = 20 } = req.query;

            // **NEW: Resolve FSRS preset (with fallback if migration not run)**
            let preset = null;
            let params = getFSRSParams(); // Default fallback
            
            try {
                const { FSRSPresetService } = await import('@/services/fsrs-preset.service.ts');
                const presetContext: any = { userId: userId as mongoose.Types.ObjectId };
                if (topicId) presetContext.topicId = new mongoose.Types.ObjectId(String(topicId));
                if (subjectId) presetContext.subjectId = new mongoose.Types.ObjectId(String(subjectId));
                if (spaceId) presetContext.spaceId = new mongoose.Types.ObjectId(String(spaceId));
                
                preset = await FSRSPresetService.resolvePreset(presetContext);
                params = FSRSPresetService.presetToFSRSParams(preset);
            } catch (presetError) {
                console.warn('[Anki] Preset resolution failed, using defaults:', presetError);
            }

            // 1. Determine Scope (Topic IDs)
            let topicIds: mongoose.Types.ObjectId[] = [];

            if (topicId) {
                topicIds = [new mongoose.Types.ObjectId(String(topicId))];
            } else if (subjectId) {
                // Find all topics in subject
                const topics = await Topic.find({ subjectId: subjectId }).select('_id');
                topicIds = topics.map(t => t._id as mongoose.Types.ObjectId);
            } else {
                if (!spaceId) return res.status(400).json({ message: "Context required (topicId or subjectId)" });
            }

            const limitNum = Number(limit);

            const validTypes = [ContentBlockType.SINGLE_SELECT_MCQ, ContentBlockType.MULTI_SELECT_MCQ, ContentBlockType.FILL_IN_THE_BLANK];

            // Use lean() to get POJOs
            const candidateQuestions = await ContentBlock.find({
                topicId: { $in: topicIds },
                kind: { $in: validTypes }
            }).select('_id kind question options blankAnswers topicId explanation hints').lean();

            const candidateIds = candidateQuestions.map(c => c._id);

            // Step B: Find DUE items from these candidates
            // "Real Anki" Logic: Learn Ahead Limit (default 20 mins)
            // If a card is due in 1 min, and we have nothing else, we should show it instead of "Finished".
            // We fetch cards due up to 20 mins in the future to allow "scanning ahead".
            const now = new Date();
            const LEARN_AHEAD_MS = 20 * 60 * 1000; // 20 minutes
            const cutoff = new Date(now.getTime() + LEARN_AHEAD_MS);

            const dueReviews = await SpacedRepetition.find({
                userId,
                questionId: { $in: candidateIds },
                nextReviewAt: { $lte: cutoff }
            })
                .sort({ nextReviewAt: 1 })
                .populate('questionId')
                .lean();

            // Step C: Find NEW items (Candidates with NO SpacedRepetition doc)
            const allUserReviewsForCandidates = await SpacedRepetition.find({
                userId,
                questionId: { $in: candidateIds }
            }).select('questionId').lean();

            const reviewedIds = new Set(allUserReviewsForCandidates.map((r: any) => r.questionId.toString()));

            const newQuestions = candidateQuestions
                .filter(q => !reviewedIds.has(q._id.toString()));

            const newItemsMapped = newQuestions.map(q => ({
                _id: null,
                userId,
                questionId: q,
                isNew: true,
                easeFactor: 2.5,
                intervalDays: 0,
                repetitions: 0,
                state: 0, // State.New
                stability: 0,
                difficulty: 0,
                elapsedDays: 0,
                scheduledDays: 0,
                learningSteps: 0,
                lapses: 0
            }));

            // Step D: Implement Card Mixing (Anki Pattern)
            // Priority: Learning/Relearning (by due) > Review (by due) > New (mixed)
            
            // Separate due cards by state
            const learningCards = dueReviews.filter((r: any) => r.state === 'learning' || r.state === 'relearning');
            const reviewCards = dueReviews.filter((r: any) => r.state === 'review');
            
            // Mix new and review cards (1 new per 2 reviews)
            const mixedQueue: any[] = [];
            let newIndex = 0;
            let reviewIndex = 0;
            
            // First, add all learning/relearning cards (highest priority)
            mixedQueue.push(...learningCards);
            
            // Then interleave review and new cards
            while (mixedQueue.length < limitNum && (reviewIndex < reviewCards.length || newIndex < newItemsMapped.length)) {
                // Add 2 review cards
                if (reviewIndex < reviewCards.length) {
                    mixedQueue.push(reviewCards[reviewIndex++]);
                }
                if (reviewIndex < reviewCards.length && mixedQueue.length < limitNum) {
                    mixedQueue.push(reviewCards[reviewIndex++]);
                }
                
                // Add 1 new card
                if (newIndex < newItemsMapped.length && mixedQueue.length < limitNum) {
                    mixedQueue.push(newItemsMapped[newIndex++]);
                }
            }
            
            const responseItems = mixedQueue.slice(0, limitNum);

            // Step E: Calculate interval previews for each item
            // Use params from preset resolution or fallback
            const fsrs = new FSRS(params);
            
            const formatMs = (ms: number): string => {
                const minutes = Math.floor(ms / 60000);
                const hours = Math.floor(ms / 3600000);
                const days = Math.floor(ms / 86400000);
                
                if (minutes < 1) return '<1m';
                if (minutes < 60) return `${minutes}m`;
                if (hours < 24) return `${hours}h`;
                return `${days}d`;
            };


            // Step D: Calculate Total Counts (for UI "X / Total")
            // Consistent with the session fetch, we count everything in the Learn Ahead window as "Due"
            const totalDueCount = await SpacedRepetition.countDocuments({
                userId,
                questionId: { $in: candidateIds },
                nextReviewAt: { $lte: cutoff }
            });

            const totalCandidateCount = candidateIds.length;
            const totalReviewedCount = await SpacedRepetition.countDocuments({
                userId,
                questionId: { $in: candidateIds }
            });
            const totalNewCount = Math.max(0, totalCandidateCount - totalReviewedCount);

            const totalCount = totalDueCount + totalNewCount;

            // **UPDATED: Include preset info if available**
            const response: any = {
                items: itemsWithIntervals,
                total: itemsWithIntervals.length
            };
            
            if (preset) {
                response.preset = {
                    id: preset._id.toString(),
                    name: preset.name,
                    description: preset.description
                };
            }
            
            return res.json(response);

        } catch (error) {
            console.error('Anki Session Error:', error);
            res.status(500).json({ message: 'Failed to fetch session' });
        }
    }

    static async submitReview(req: Request, res: Response) {
        try {
            const user = req.user;
            if (!user) throw new Error('User not found');
            const userId = user._id;
            const { questionId, rating } = req.body; // rating: 'Again' | 'Hard' | 'Good' | 'Easy'

            if (!questionId || !rating) {
                return res.status(400).json({ message: 'Missing questionId or rating' });
            }

            let sr = await SpacedRepetition.findOne({ userId, questionId });
            const now = new Date();

            // 1. Initialize FSRS with shared configuration
            const params = getFSRSParams();
            const fsrs = new FSRS(params);

            let card: Card;

            if (!sr) {
                // Should not happen theoretically if flow is correct, but handle NEW card case
                // Create a clean "New" card
                card = createEmptyCard(now);
                // We must create the document too
                sr = new SpacedRepetition({
                    userId,
                    questionId,
                    state: 'new', // Legacy sync
                    createdAt: now,
                    // FSRS defaults
                    stability: 0,
                    difficulty: 0,
                    elapsedDays: 0,
                    scheduledDays: 0,
                    learningSteps: 0,
                    lapses: 0,
                    repetitions: 0
                });
            } else {
                // Reconstruct Card from DB
                // Map legacy state string to FSRS State Enum if needed, or rely on stored values
                // If FSRS fields are 0 (never used), FSRS will treat as New or handle gracefully if we set State correctly.
                
                let state = State.New;
                if (sr.state === 'learning') state = State.Learning;
                if (sr.state === 'review') state = State.Review;
                if (sr.state === 'relearning') state = State.Relearning;
                
                // If we have strict FSRS state stored in DB (as number) we could use that, 
                // but for now we map string -> enum to be safe with hybrid data.
                
                card = createEmptyCard(now); // Start with default
                card.due = sr.nextReviewAt;
                if (sr.lastReviewedAt) {
                    card.last_review = sr.lastReviewedAt;
                }
                card.reps = sr.repetitions;
                card.stability = sr.stability || 0;
                card.difficulty = sr.difficulty || 0;
                card.elapsed_days = sr.elapsedDays || 0;
                card.scheduled_days = sr.scheduledDays || 0;
                card.learning_steps = sr.learningSteps || 0;
                card.lapses = sr.lapses || 0;
                card.state = state;
            }

            // 2. Map Rating
            let fsrsRating = Rating.Good;
            switch(rating) {
                case 'Again': fsrsRating = Rating.Again; break;
                case 'Hard': fsrsRating = Rating.Hard; break;
                case 'Good': fsrsRating = Rating.Good; break;
                case 'Easy': fsrsRating = Rating.Easy; break;
            }

            // 3. Schedule
            // If the card is incorrectly marked as 'New' in DB but has history, `repeat` handles it?
            // FSRS expects `repeat` to be called with the card and the review time
            const schedulingCards = fsrs.repeat(card, now);
            
            // schedulingCards[rating] gives the specific result RecordLogItem
            // We want the new Card state from it.
            const resultRecord = schedulingCards[fsrsRating];
            const newCard = resultRecord.card;

            // 4. Update DB
            sr.nextReviewAt = newCard.due;
            sr.lastReviewedAt = newCard.last_review || now; // If undefined, fallback or keep? Usually has value after review.
            sr.repetitions = newCard.reps;
            sr.stability = newCard.stability;
            sr.difficulty = newCard.difficulty;
            sr.elapsedDays = newCard.elapsed_days;
            sr.scheduledDays = newCard.scheduled_days;
            sr.learningSteps = newCard.learning_steps;
            sr.lapses = newCard.lapses;
            
            // Sync Legacy State String
            switch(newCard.state) {
                case State.New: sr.state = 'new'; break;
                case State.Learning: sr.state = 'learning'; break;
                case State.Review: sr.state = 'review'; break;
                case State.Relearning: sr.state = 'relearning'; break;
            }

            await sr.save();

            // 5. Calculate next intervals for UI preview (for next card)
            // Use the UPDATED card state to preview what would happen next
            const previewCard = createEmptyCard(now);
            previewCard.due = sr.nextReviewAt;
            previewCard.last_review = sr.lastReviewedAt;
            previewCard.reps = sr.repetitions;
            previewCard.stability = sr.stability;
            previewCard.difficulty = sr.difficulty;
            previewCard.elapsed_days = sr.elapsedDays;
            previewCard.scheduled_days = sr.scheduledDays;
            previewCard.learning_steps = sr.learningSteps;
            previewCard.lapses = sr.lapses;
            
            let previewState = State.New;
            if (sr.state === 'learning') previewState = State.Learning;
            if (sr.state === 'review') previewState = State.Review;
            if (sr.state === 'relearning') previewState = State.Relearning;
            previewCard.state = previewState;

            // Calculate what would happen for each rating
            const nextScheduling = fsrs.repeat(previewCard, now);
            
            const formatMs = (ms: number): string => {
                const minutes = Math.floor(ms / 60000);
                const hours = Math.floor(ms / 3600000);
                const days = Math.floor(ms / 86400000);
                
                if (minutes < 1) return '<1m';
                if (minutes < 60) return `${minutes}m`;
                if (hours < 24) return `${hours}h`;
                return `${days}d`;
            };

            const nextIntervals = {
                Again: formatMs(nextScheduling[Rating.Again].card.due.getTime() - now.getTime()),
                Hard: formatMs(nextScheduling[Rating.Hard].card.due.getTime() - now.getTime()),
                Good: formatMs(nextScheduling[Rating.Good].card.due.getTime() - now.getTime()),
                Easy: formatMs(nextScheduling[Rating.Easy].card.due.getTime() - now.getTime())
            };

            // Return with next intervals for UI
            const response = {
                ...sr.toObject(),
                nextIntervals
            };

            res.status(200).json(response);
        } catch (error) {
            console.error('Review Submit Error:', error);
            res.status(500).json({ message: 'Failed to submit review' });
        }
    }
}
